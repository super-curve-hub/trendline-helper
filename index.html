<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Trendline Break Helper (4H→15M)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif; margin: 16px; }
    .wrap { display: grid; grid-template-columns: 420px 1fr; gap: 16px; align-items: start; }
    @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; } }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    .row { display: grid; grid-template-columns: 160px 1fr; gap: 8px; margin: 8px 0; align-items: center; }
    input, select, button { width: 100%; padding: 8px; }
    button { cursor: pointer; }
    canvas { width: 100%; border: 1px solid #ddd; border-radius: 10px; }
    .hint { font-size: 12px; color: #444; line-height: 1.35; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#f5f5f5; padding:1px 6px; border-radius:6px; }
    .tool { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .tool button { width:auto; }
    .ok { color: #0a7; font-weight: 600; }
    .ng { color: #c33; font-weight: 600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Trendline Break Helper（4Hでライン確定 → 15Mで執行）</h1>
  <p class="hint">
    注意：本ツールは教育・検証補助用です。売買判断の最終責任は利用者にあります。画像はブラウザ内で処理され、外部送信しません。
  </p>

  <div class="wrap">
    <div class="card">
      <div class="row">
        <div>チャート画像</div>
        <input id="file" type="file" accept="image/*" />
      </div>

      <div class="row">
        <div>方向</div>
        <select id="side">
          <option value="long">Long（上抜け）</option>
          <option value="short">Short（下抜け）</option>
        </select>
      </div>

      <div class="row">
        <div>buf（ブレイク判定）</div>
        <input id="buf" type="number" step="0.01" value="0.05" />
      </div>
      <div class="row">
        <div>bufS（ストップ余裕）</div>
        <input id="bufS" type="number" step="0.01" value="0.05" />
      </div>
      <div class="row">
        <div>Rmax（低リスク上限）</div>
        <input id="rmax" type="number" step="0.01" value="0.30" />
      </div>
      <div class="row">
        <div>TP倍率（主）</div>
        <input id="k" type="number" step="0.1" value="1.5" />
      </div>

      <div class="row">
        <div>現在値（任意）</div>
        <input id="pxNow" type="number" step="0.001" placeholder="クリックで取得 or 手入力" />
      </div>

      <div class="tool">
        <button id="tCal1">①キャリブ点1</button>
        <button id="tCal2">①キャリブ点2</button>
        <button id="tNowX">②Now位置</button>
        <button id="tAL">③Action Line(2点)</button>
        <button id="tSL">④Safety Line(2点)</button>
        <button id="tPx">⑤現在値クリック</button>
      </div>

      <div class="tool">
        <button id="calc">計算</button>
        <button id="reset">リセット</button>
      </div>

      <div class="hint">
        手順：<br/>
        1) <span class="kbd">①キャリブ点1</span>→チャート上の価格軸付近をクリック→価格入力<br/>
        2) <span class="kbd">①キャリブ点2</span>→別の価格位置をクリック→価格入力<br/>
        3) <span class="kbd">②Now位置</span>→最新足のX位置をクリック（右端付近）<br/>
        4) <span class="kbd">③AL</span>→2点クリック（ブレイク対象ライン）<br/>
        5) <span class="kbd">④SL</span>→2点クリック（撤退/ストップ基準）<br/>
        6) 任意：<span class="kbd">⑤現在値クリック</span>（終値付近をクリック）<br/>
      </div>
    </div>

    <div>
      <canvas id="cv" width="1200" height="800"></canvas>
      <div class="card" style="margin-top:12px;">
        <div id="status" class="hint"></div>
        <div id="out" class="mono"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const el = (id) => document.getElementById(id);

  const state = {
    tool: null, // 'cal1'|'cal2'|'nowx'|'al'|'sl'|'px'
    img: null,
    // calibration points (pixel y + price)
    cal: { p1: null, p2: null }, // {x,y,price}
    // now x in pixels
    nowX: null,
    // lines defined by 2 points in pixel coords
    AL: { a: null, b: null },
    SL: { a: null, b: null },
    // current price (optional)
    pxNow: null, // number
  };

  function clear() {
    ctx.clearRect(0, 0, cv.width, cv.height);
  }

  function drawBase() {
    clear();
    if (!state.img) return;
    // fit image into canvas while preserving aspect ratio
    const iw = state.img.width, ih = state.img.height;
    const cw = cv.width, ch = cv.height;
    const scale = Math.min(cw / iw, ch / ih);
    const w = iw * scale, h = ih * scale;
    const ox = (cw - w) / 2, oy = (ch - h) / 2;
    ctx.drawImage(state.img, ox, oy, w, h);

    // store transform for mapping click coords to image coords if needed
    state._draw = { scale, ox, oy, w, h, iw, ih };
  }

  function drawPoint(pt, label, color = '#111') {
    if (!pt) return;
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = color;
    ctx.font = '16px system-ui';
    ctx.fillText(label, pt.x + 10, pt.y - 10);
    ctx.restore();
  }

  function drawLine(p, q, label, color = '#111') {
    if (!p || !q) return;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(q.x, q.y);
    ctx.stroke();
    ctx.font = '16px system-ui';
    ctx.fillStyle = color;
    ctx.fillText(label, (p.x + q.x)/2 + 10, (p.y + q.y)/2);
    ctx.restore();
  }

  function drawNowX() {
    if (state.nowX == null) return;
    ctx.save();
    ctx.strokeStyle = '#888';
    ctx.setLineDash([6, 6]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(state.nowX, 0);
    ctx.lineTo(state.nowX, cv.height);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#888';
    ctx.font = '16px system-ui';
    ctx.fillText('NOW', state.nowX + 8, 24);
    ctx.restore();
  }

  function redraw() {
    drawBase();
    // calibration points
    drawPoint(state.cal.p1, 'CAL1', '#6a5acd');
    drawPoint(state.cal.p2, 'CAL2', '#6a5acd');
    // now x
    drawNowX();
    // lines
    drawLine(state.AL.a, state.AL.b, 'Action Line', '#1e90ff');
    drawLine(state.SL.a, state.SL.b, 'Safety Line', '#f4b400');
  }

  function canvasPos(evt) {
    const rect = cv.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (cv.width / rect.width);
    const y = (evt.clientY - rect.top) * (cv.height / rect.height);
    return { x, y };
  }

  function hasCalibration() {
    return state.cal.p1 && state.cal.p2 && Number.isFinite(state.cal.p1.price) && Number.isFinite(state.cal.p2.price);
  }

  // linear mapping y(px) -> price
  function priceFromY(y) {
    if (!hasCalibration()) return null;
    const { y: y1, price: p1 } = state.cal.p1;
    const { y: y2, price: p2 } = state.cal.p2;
    // y increases downward; price usually increases upward => slope negative if user clicks correctly
    const m = (p2 - p1) / (y2 - y1);
    return p1 + m * (y - y1);
  }

  function yFromPrice(price) {
    if (!hasCalibration()) return null;
    const { y: y1, price: p1 } = state.cal.p1;
    const { y: y2, price: p2 } = state.cal.p2;
    const m = (p2 - p1) / (y2 - y1);
    if (m === 0) return null;
    return y1 + (price - p1) / m;
  }

  function lineYatX(line, x) {
    if (!line.a || !line.b) return null;
    const { x: x1, y: y1 } = line.a;
    const { x: x2, y: y2 } = line.b;
    if (x2 === x1) return null;
    const m = (y2 - y1) / (x2 - x1);
    return y1 + m * (x - x1);
  }

  function linePriceAtNow(line) {
    if (state.nowX == null) return null;
    const y = lineYatX(line, state.nowX);
    if (y == null) return null;
    return priceFromY(y);
  }

  function fmt(x, d=3) {
    if (!Number.isFinite(x)) return '—';
    return x.toFixed(d);
  }

  function setStatus(msg) {
    el('status').textContent = msg;
  }

  function output(text) {
    el('out').textContent = text;
  }

  // tool buttons
  el('tCal1').onclick = () => { state.tool = 'cal1'; setStatus('①キャリブ点1：クリックして価格を入力'); };
  el('tCal2').onclick = () => { state.tool = 'cal2'; setStatus('①キャリブ点2：クリックして価格を入力'); };
  el('tNowX').onclick = () => { state.tool = 'nowx'; setStatus('②Now位置：最新足のX位置をクリック'); };
  el('tAL').onclick = () => { state.tool = 'al'; setStatus('③Action Line：2点クリック'); state._tmp = []; };
  el('tSL').onclick = () => { state.tool = 'sl'; setStatus('④Safety Line：2点クリック'); state._tmp = []; };
  el('tPx').onclick = () => { state.tool = 'px'; setStatus('⑤現在値：終値付近をクリック（任意）'); };

  el('reset').onclick = () => {
    state.tool = null;
    state.img = null;
    state.cal = { p1:null, p2:null };
    state.nowX = null;
    state.AL = { a:null, b:null };
    state.SL = { a:null, b:null };
    state.pxNow = null;
    el('file').value = '';
    el('pxNow').value = '';
    setStatus('リセットしました。画像をアップロードしてください。');
    output('');
    clear();
  };

  el('file').addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = () => {
      state.img = img;
      // redraw base
      redraw();
      setStatus('画像を読み込みました。①キャリブ点1から進めてください。');
    };
    img.src = url;
  });

  cv.addEventListener('click', (evt) => {
    if (!state.img) return;

    const p = canvasPos(evt);

    if (state.tool === 'cal1') {
      const v = prompt('CAL1の価格を入力（例: 157.850）');
      const price = v == null ? NaN : Number(v);
      if (!Number.isFinite(price)) return;
      state.cal.p1 = { ...p, price };
      redraw();
      setStatus('CAL1設定済み。次は①キャリブ点2。');
      return;
    }
    if (state.tool === 'cal2') {
      const v = prompt('CAL2の価格を入力（例: 157.300）');
      const price = v == null ? NaN : Number(v);
      if (!Number.isFinite(price)) return;
      state.cal.p2 = { ...p, price };
      redraw();
      setStatus('キャリブ完了。次は②Now位置。');
      return;
    }
    if (state.tool === 'nowx') {
      state.nowX = p.x;
      redraw();
      setStatus('Now位置設定済み。次は③Action Line。');
      return;
    }
    if (state.tool === 'al') {
      state._tmp = state._tmp || [];
      state._tmp.push(p);
      if (state._tmp.length === 2) {
        state.AL = { a: state._tmp[0], b: state._tmp[1] };
        state._tmp = [];
        redraw();
        setStatus('Action Line設定済み。次は④Safety Line。');
      } else {
        setStatus('Action Line：もう1点クリック');
      }
      return;
    }
    if (state.tool === 'sl') {
      state._tmp = state._tmp || [];
      state._tmp.push(p);
      if (state._tmp.length === 2) {
        state.SL = { a: state._tmp[0], b: state._tmp[1] };
        state._tmp = [];
        redraw();
        setStatus('Safety Line設定済み。任意で⑤現在値クリック、または計算へ。');
      } else {
        setStatus('Safety Line：もう1点クリック');
      }
      return;
    }
    if (state.tool === 'px') {
      const px = priceFromY(p.y);
      if (px == null) return;
      state.pxNow = px;
      el('pxNow').value = px.toFixed(3);
      redraw();
      setStatus('現在値を取得しました。計算してください。');
      return;
    }
  });

  el('pxNow').addEventListener('input', () => {
    const v = Number(el('pxNow').value);
    state.pxNow = Number.isFinite(v) ? v : null;
  });

  function drawHorizontal(price, label, color) {
    const y = yFromPrice(price);
    if (y == null) return;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(cv.width, y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = color;
    ctx.font = '16px system-ui';
    ctx.fillText(`${label}: ${price.toFixed(3)}`, 10, y - 8);
    ctx.restore();
  }

  el('calc').onclick = () => {
    // validate
    if (!state.img) return setStatus('画像がありません。');
    if (!hasCalibration()) return setStatus('価格キャリブ（①）が未完了です。');
    if (state.nowX == null) return setStatus('Now位置（②）が未設定です。');
    if (!state.AL.a || !state.AL.b) return setStatus('Action Line（③）が未設定です。');
    if (!state.SL.a || !state.SL.b) return setStatus('Safety Line（④）が未設定です。');

    const side = el('side').value;
    const buf = Number(el('buf').value);
    const bufS = Number(el('bufS').value);
    const rmax = Number(el('rmax').value);
    const k = Number(el('k').value);

    const alNow = linePriceAtNow(state.AL);
    const slNow = linePriceAtNow(state.SL);

    if (!Number.isFinite(alNow) || !Number.isFinite(slNow)) {
      return setStatus('ラインの計算に失敗しました（垂直線/キャリブ不正の可能性）。');
    }

    let entryTrig, stop, risk;
    if (side === 'long') {
      entryTrig = alNow + buf;
      stop = slNow - bufS;
      risk = entryTrig - stop;
    } else {
      entryTrig = alNow - buf;
      stop = slNow + bufS;
      risk = stop - entryTrig;
    }

    const lowRisk = Number.isFinite(rmax) ? (risk <= rmax) : false;

    // TP: 1R, kR, 2R
    const tp1 = (side === 'long') ? (entryTrig + 1.0 * risk) : (entryTrig - 1.0 * risk);
    const tpk = (side === 'long') ? (entryTrig + k * risk) : (entryTrig - k * risk);
    const tp2 = (side === 'long') ? (entryTrig + 2.0 * risk) : (entryTrig - 2.0 * risk);

    // already broke?
    const pxNow = state.pxNow ?? (Number.isFinite(Number(el('pxNow').value)) ? Number(el('pxNow').value) : null);
    let broke = null;
    if (Number.isFinite(pxNow)) {
      broke = (side === 'long') ? (pxNow >= entryTrig) : (pxNow <= entryTrig);
    }

    // redraw overlay
    redraw();
    drawHorizontal(entryTrig, 'ENTRY(TRIG)', '#1e90ff');
    drawHorizontal(stop, 'STOP', '#f4b400');
    drawHorizontal(tpk, `TP(${k}R)`, '#111');

    const lines = [];
    lines.push(`SIDE: ${side.toUpperCase()}`);
    lines.push(`AL(now): ${fmt(alNow)} / SL(now): ${fmt(slNow)}`);
    lines.push(`ENTRYトリガー: ${fmt(entryTrig)}`);
    lines.push(`STOP:         ${fmt(stop)}`);
    lines.push(`RISK:         ${fmt(risk)}  （低リスク判定: ${lowRisk ? 'YES' : 'NO'} / Rmax=${fmt(rmax)}）`);
    lines.push('');
    lines.push(`TP(1R):  ${fmt(tp1)}`);
    lines.push(`TP(${k}R): ${fmt(tpk)}`);
    lines.push(`TP(2R):  ${fmt(tp2)}`);
    lines.push('');
    if (broke !== null) {
      lines.push(`現在値: ${fmt(pxNow)} / ブレイク済み?: ${broke ? 'YES' : 'NO'}`);
    } else {
      lines.push(`現在値: 未入力（任意）`);
    }

    output(lines.join('\n'));
    setStatus('計算しました。水平線（ENTRY/STOP/TP）を描画しました。');
  };

  // init
  setStatus('画像をアップロードしてください。');
})();
</script>
</body>
</html>
